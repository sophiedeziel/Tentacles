# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mock_redis` gem.
# Please instead update this file by running `bin/tapioca gem mock_redis`.


# Defines the gem version.
#
# source://mock_redis//lib/mock_redis/error.rb#1
class MockRedis
  include ::MockRedis::UndefRedisMethods

  # @return [MockRedis] a new instance of MockRedis
  #
  # source://mock_redis//lib/mock_redis.rb#34
  def initialize(*args); end

  # source://mock_redis//lib/mock_redis.rb#73
  def client; end

  # source://mock_redis//lib/mock_redis.rb#77
  def connect; end

  # source://mock_redis//lib/mock_redis.rb#61
  def db; end

  # source://mock_redis//lib/mock_redis.rb#53
  def host; end

  # source://mock_redis//lib/mock_redis.rb#48
  def id; end

  # source://mock_redis//lib/mock_redis.rb#48
  def location; end

  # source://mock_redis//lib/mock_redis.rb#65
  def logger; end

  # source://mock_redis//lib/mock_redis.rb#93
  def method_missing(method, *args, **_arg2, &block); end

  # Returns the value of attribute options.
  #
  # source://mock_redis//lib/mock_redis.rb#16
  def options; end

  # source://mock_redis//lib/mock_redis.rb#57
  def port; end

  # source://mock_redis//lib/mock_redis.rb#81
  def reconnect; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis.rb#89
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis.rb#69
  def time_at(timestamp); end

  # @yield [_self]
  # @yieldparam _self [MockRedis] the object that the method was called on
  #
  # source://mock_redis//lib/mock_redis.rb#85
  def with; end

  protected

  # source://mock_redis//lib/mock_redis.rb#106
  def _parse_options(options); end

  # source://mock_redis//lib/mock_redis.rb#150
  def logging(commands); end

  private

  # source://mock_redis//lib/mock_redis.rb#99
  def initialize_copy(source); end

  class << self
    # source://mock_redis//lib/mock_redis.rb#30
    def connect(*args); end
  end
end

# source://mock_redis//lib/mock_redis/assertions.rb#7
module MockRedis::Assertions
  private

  # source://mock_redis//lib/mock_redis/assertions.rb#10
  def assert_has_args(args, command); end

  # source://mock_redis//lib/mock_redis/assertions.rb#19
  def assert_type(*args); end
end

# source://mock_redis//lib/mock_redis/connection_method.rb#2
module MockRedis::ConnectionMethod
  # source://mock_redis//lib/mock_redis/connection_method.rb#3
  def connection; end
end

# source://mock_redis//lib/mock_redis.rb#18
MockRedis::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/assertions.rb#5
MockRedis::DUMP_TYPES = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/database.rb#18
class MockRedis::Database
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods
  include ::MockRedis::HashMethods
  include ::MockRedis::ListMethods
  include ::MockRedis::SetMethods
  include ::MockRedis::StringMethods
  include ::MockRedis::ZsetMethods
  include ::MockRedis::SortMethod
  include ::MockRedis::InfoMethod
  include ::MockRedis::GeospatialMethods
  include ::MockRedis::StreamMethods
  include ::MockRedis::ConnectionMethod
  include ::MockRedis::MemoryMethod

  # @return [Database] a new instance of Database
  #
  # source://mock_redis//lib/mock_redis/database.rb#34
  def initialize(base, *_args); end

  # source://mock_redis//lib/mock_redis/database.rb#55
  def auth(_); end

  # source://mock_redis//lib/mock_redis/database.rb#59
  def bgrewriteaof; end

  # source://mock_redis//lib/mock_redis/database.rb#63
  def bgsave; end

  # FIXME: Current implementation of `call` does not work propetly with kwarg-options.
  # i.e. `call("EXPIRE", "foo", 40, "NX")` (which redis-rb will simply transmit to redis-server)
  # will be passed to `#expire` without keywords transformation.
  #
  # source://mock_redis//lib/mock_redis/database.rb#51
  def call(command, &_block); end

  # source://mock_redis//lib/mock_redis/database.rb#67
  def close; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#73
  def connected?; end

  # Returns the value of attribute data.
  #
  # source://mock_redis//lib/mock_redis/database.rb#32
  def data; end

  # source://mock_redis//lib/mock_redis/database.rb#77
  def dbsize; end

  # source://mock_redis//lib/mock_redis/database.rb#81
  def del(*keys); end

  # source://mock_redis//lib/mock_redis/database.rb#67
  def disconnect; end

  # source://mock_redis//lib/mock_redis/database.rb#67
  def disconnect!; end

  # source://mock_redis//lib/mock_redis/database.rb#154
  def dump(key); end

  # source://mock_redis//lib/mock_redis/database.rb#93
  def echo(msg); end

  # source://mock_redis//lib/mock_redis/database.rb#301
  def eval(*args); end

  # source://mock_redis//lib/mock_redis/database.rb#299
  def evalsha(*args); end

  # source://mock_redis//lib/mock_redis/database.rb#140
  def exists(*keys); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#144
  def exists?(*keys); end

  # source://mock_redis//lib/mock_redis/database.rb#97
  def expire(key, seconds, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil)); end

  # This method isn't private, but it also isn't a Redis command, so
  # it doesn't belong up above with all the Redis commands.
  #
  # source://mock_redis//lib/mock_redis/database.rb#391
  def expire_keys; end

  # Returns the value of attribute expire_times.
  #
  # source://mock_redis//lib/mock_redis/database.rb#32
  def expire_times; end

  # source://mock_redis//lib/mock_redis/database.rb#111
  def expireat(key, timestamp, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#149
  def flushdb; end

  # source://mock_redis//lib/mock_redis/database.rb#170
  def keys(format = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#188
  def lastsave; end

  # source://mock_redis//lib/mock_redis/database.rb#270
  def now; end

  # source://mock_redis//lib/mock_redis/database.rb#192
  def persist(key); end

  # source://mock_redis//lib/mock_redis/database.rb#103
  def pexpire(key, ms, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#117
  def pexpireat(key, timestamp_ms, nx: T.unsafe(nil), xx: T.unsafe(nil), lt: T.unsafe(nil), gt: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#201
  def ping(response = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#257
  def pttl(key); end

  # source://mock_redis//lib/mock_redis/database.rb#205
  def quit; end

  # source://mock_redis//lib/mock_redis/database.rb#209
  def randomkey; end

  # source://mock_redis//lib/mock_redis/database.rb#213
  def rename(key, newkey); end

  # source://mock_redis//lib/mock_redis/database.rb#229
  def renamenx(key, newkey); end

  # source://mock_redis//lib/mock_redis/database.rb#159
  def restore(key, ttl, value, replace: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#242
  def save; end

  # source://mock_redis//lib/mock_redis/database.rb#174
  def scan(cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/database.rb#178
  def scan_each(opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/database.rb#297
  def script(subcommand, *args); end

  # source://mock_redis//lib/mock_redis/database.rb#270
  def time; end

  # source://mock_redis//lib/mock_redis/database.rb#246
  def ttl(key); end

  # source://mock_redis//lib/mock_redis/database.rb#277
  def type(key); end

  # source://mock_redis//lib/mock_redis/database.rb#81
  def unlink(*keys); end

  private

  # source://mock_redis//lib/mock_redis/database.rb#305
  def assert_valid_timeout(timeout); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#315
  def can_incr?(value); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#319
  def can_incr_float?(value); end

  # source://mock_redis//lib/mock_redis/database.rb#336
  def expiration(key); end

  # source://mock_redis//lib/mock_redis/database.rb#323
  def extract_timeout(arglist); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#340
  def has_expiration?(key); end

  # source://mock_redis//lib/mock_redis/database.rb#40
  def initialize_copy(_source); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#348
  def looks_like_float?(str); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#344
  def looks_like_integer?(str); end

  # source://mock_redis//lib/mock_redis/database.rb#360
  def redis_pattern_to_ruby_regex(pattern); end

  # source://mock_redis//lib/mock_redis/database.rb#369
  def remove_expiration(key); end

  # source://mock_redis//lib/mock_redis/database.rb#375
  def set_expiration(key, time); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/database.rb#352
  def should_update_expiration?(expiry, new_expiry, nx:, xx:, lt:, gt:); end

  # source://mock_redis//lib/mock_redis/database.rb#382
  def zero_pad(string, desired_length); end
end

# source://mock_redis//lib/mock_redis/error.rb#2
module MockRedis::Error
  private

  # source://mock_redis//lib/mock_redis/error.rb#5
  def build(error_class, message, database); end

  # source://mock_redis//lib/mock_redis/error.rb#23
  def command_error(message, database); end

  # source://mock_redis//lib/mock_redis/error.rb#19
  def syntax_error(database); end

  # source://mock_redis//lib/mock_redis/error.rb#11
  def wrong_type_error(database); end

  class << self
    # source://mock_redis//lib/mock_redis/error.rb#5
    def build(error_class, message, database); end

    # source://mock_redis//lib/mock_redis/error.rb#23
    def command_error(message, database); end

    # source://mock_redis//lib/mock_redis/error.rb#19
    def syntax_error(database); end

    # source://mock_redis//lib/mock_redis/error.rb#11
    def wrong_type_error(database); end
  end
end

# source://mock_redis//lib/mock_redis/expire_wrapper.rb#4
class MockRedis::ExpireWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [ExpireWrapper] a new instance of ExpireWrapper
  #
  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#11
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#15
  def method_missing(method, *args, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#7
  def respond_to?(method, include_private = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/expire_wrapper.rb#20
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/future.rb#4
class MockRedis::Future
  # @return [Future] a new instance of Future
  #
  # source://mock_redis//lib/mock_redis/future.rb#7
  def initialize(command, block = T.unsafe(nil)); end

  # Returns the value of attribute block.
  #
  # source://mock_redis//lib/mock_redis/future.rb#5
  def block; end

  # Returns the value of attribute command.
  #
  # source://mock_redis//lib/mock_redis/future.rb#5
  def command; end

  # source://mock_redis//lib/mock_redis/future.rb#18
  def store_result(result); end

  # @raise [FutureNotReady]
  #
  # source://mock_redis//lib/mock_redis/future.rb#13
  def value; end
end

# source://mock_redis//lib/mock_redis/future.rb#2
class MockRedis::FutureNotReady < ::RuntimeError; end

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#4
module MockRedis::GeospatialMethods
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#17
  def geoadd(key, *args, **_arg2); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#28
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#46
  def geohash(key, members); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#68
  def geopos(key, members); end

  private

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#158
  def calculate_approximate_area(hash, lng_range, lat_range); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#234
  def deg_rad(ang); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#177
  def deinterleave(bits); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#206
  def format_decoded_coord(coord); end

  # Decodes ZSET score to coordinates pair
  #
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#149
  def geohash_decode(hash, lng_range = T.unsafe(nil), lat_range = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#221
  def geohash_distance(lng1d, lat1d, lng2d, lat2d); end

  # Returns ZSET score for passed coordinates
  #
  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#113
  def geohash_encode(lng, lat, lng_range = T.unsafe(nil), lat_range = T.unsafe(nil), step = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#125
  def interleave(x, y); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#94
  def parse_point(point); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#82
  def parse_points(args); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#214
  def parse_unit(unit); end

  # source://mock_redis//lib/mock_redis/geospatial_methods.rb#238
  def rad_deg(ang); end
end

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#14
MockRedis::GeospatialMethods::D_R = T.let(T.unsafe(nil), Float)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#15
MockRedis::GeospatialMethods::EARTH_RADIUS_IN_METERS = T.let(T.unsafe(nil), Float)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#6
MockRedis::GeospatialMethods::LAT_RANGE = T.let(T.unsafe(nil), Range)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#5
MockRedis::GeospatialMethods::LNG_RANGE = T.let(T.unsafe(nil), Range)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#7
MockRedis::GeospatialMethods::STEP = T.let(T.unsafe(nil), Integer)

# source://mock_redis//lib/mock_redis/geospatial_methods.rb#8
MockRedis::GeospatialMethods::UNITS = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/hash_methods.rb#6
module MockRedis::HashMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/hash_methods.rb#10
  def hdel(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#28
  def hexists(key, field); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#34
  def hget(key, field); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#40
  def hgetall(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#46
  def hincrby(key, field, increment); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#62
  def hincrbyfloat(key, field, increment); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#79
  def hkeys(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#85
  def hlen(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#91
  def hmget(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#110
  def hmset(key, *kvpairs); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#147
  def hscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#154
  def hscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#166
  def hset(key, *args); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#186
  def hsetnx(key, field, value); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#196
  def hvals(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#99
  def mapped_hmget(key, *fields); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#135
  def mapped_hmset(key, hash); end

  private

  # source://mock_redis//lib/mock_redis/hash_methods.rb#212
  def assert_hashy(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/hash_methods.rb#208
  def hashy?(key); end

  # source://mock_redis//lib/mock_redis/hash_methods.rb#204
  def with_hash_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/indifferent_hash.rb#2
class MockRedis::IndifferentHash < ::Hash
  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/indifferent_hash.rb#3
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/indifferent_hash.rb#7
  def key?(key); end
end

# source://mock_redis//lib/mock_redis/info_method.rb#2
module MockRedis::InfoMethod
  # source://mock_redis//lib/mock_redis/info_method.rb#144
  def info(section = T.unsafe(nil)); end
end

# source://mock_redis//lib/mock_redis/info_method.rb#139
MockRedis::InfoMethod::ALL_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#20
MockRedis::InfoMethod::CLIENTS_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#107
MockRedis::InfoMethod::COMMAND_STATS_COMBINED_INFO = T.let(T.unsafe(nil), Hash)

# The Ruby Redis client returns commandstats differently when it's called as
# "INFO commandstats".
#
# source://mock_redis//lib/mock_redis/info_method.rb#87
MockRedis::InfoMethod::COMMAND_STATS_SOLO_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#73
MockRedis::InfoMethod::CPU_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#128
MockRedis::InfoMethod::DEFAULT_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#80
MockRedis::InfoMethod::KEYSPACE_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#27
MockRedis::InfoMethod::MEMORY_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#38
MockRedis::InfoMethod::PERSISTENCE_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#68
MockRedis::InfoMethod::REPLICATION_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#3
MockRedis::InfoMethod::SERVER_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/info_method.rb#54
MockRedis::InfoMethod::STATS_INFO = T.let(T.unsafe(nil), Hash)

# source://mock_redis//lib/mock_redis/list_methods.rb#5
module MockRedis::ListMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/list_methods.rb#9
  def blmove(source, destination, wherefrom, whereto, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#23
  def blpop(*args); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#36
  def brpop(*args); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#49
  def brpoplpush(source, destination, timeout: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#61
  def lindex(key, index); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#65
  def linsert(key, position, pivot, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#89
  def llen(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#119
  def lmove(source, destination, wherefrom, whereto); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#93
  def lmpop(*keys, **options); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#134
  def lpop(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#143
  def lpush(key, values); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#150
  def lpushx(key, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#160
  def lrange(key, start, stop); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#165
  def lrem(key, count, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#186
  def lset(key, index, value); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#202
  def ltrim(key, start, stop); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#209
  def rpop(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#218
  def rpoplpush(source, destination); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#224
  def rpush(key, values); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#231
  def rpushx(key, value); end

  private

  # source://mock_redis//lib/mock_redis/list_methods.rb#255
  def assert_listy(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#262
  def assert_where_field(where, argument_name); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#268
  def first_nonempty_list(keys); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/list_methods.rb#243
  def list_at?(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/list_methods.rb#251
  def listy?(key); end

  # source://mock_redis//lib/mock_redis/list_methods.rb#247
  def with_list_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/memory_method.rb#2
module MockRedis::MemoryMethod
  # @raise [ArgumentError]
  #
  # source://mock_redis//lib/mock_redis/memory_method.rb#3
  def memory(usage, key = T.unsafe(nil), *_options); end
end

# source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#4
class MockRedis::MultiDbWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [MultiDbWrapper] a new instance of MultiDbWrapper
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#7
  def initialize(db); end

  # Redis commands
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#33
  def flushall; end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#20
  def method_missing(method, *args, **_arg2, &block); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#38
  def move(key, db_index); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#16
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#72
  def select(db_index); end

  private

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#79
  def current_db; end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#83
  def db(index); end

  # source://mock_redis//lib/mock_redis/multi_db_wrapper.rb#24
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#2
class MockRedis::PipelinedWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [PipelinedWrapper] a new instance of PipelinedWrapper
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#9
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#21
  def method_missing(method, *args, **_arg2, &block); end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#31
  def pipelined(_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#5
  def respond_to?(method, include_private = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#65
  def in_pipeline?; end

  # source://mock_redis//lib/mock_redis/pipelined_wrapper.rb#15
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/set_methods.rb#5
module MockRedis::SetMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/set_methods.rb#9
  def sadd(key, *members); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/set_methods.rb#31
  def sadd?(key, members); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#36
  def scard(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#41
  def sdiff(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#46
  def sdiffstore(destination, *keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#55
  def sinter(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#63
  def sinterstore(destination, *keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#72
  def sismember(key, member); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#86
  def smembers(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#77
  def smismember(key, *members); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#91
  def smove(src, dest, member); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#104
  def spop(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#124
  def srandmember(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#138
  def srem(key, *members); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/set_methods.rb#154
  def srem?(key, members); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#159
  def sscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#163
  def sscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#173
  def sunion(*keys); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#178
  def sunionstore(destination, *keys); end

  private

  # source://mock_redis//lib/mock_redis/set_methods.rb#212
  def assert_sety(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/set_methods.rb#208
  def sety?(key); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#188
  def with_set_at(key, &blk); end

  # source://mock_redis//lib/mock_redis/set_methods.rb#192
  def with_sets_at(*keys, &blk); end
end

# source://mock_redis//lib/mock_redis/sort_method.rb#4
module MockRedis::SortMethod
  include ::MockRedis::Assertions

  # source://mock_redis//lib/mock_redis/sort_method.rb#7
  def sort(key, options = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/sort_method.rb#71
  def lookup_from_pattern(pattern, element); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#33
  def project(enumerable, by, get_patterns); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#64
  def slice(sorted, limit); end

  # source://mock_redis//lib/mock_redis/sort_method.rb#50
  def sort_by(projected, direction); end
end

# source://mock_redis//lib/mock_redis/sort_method.rb#30
MockRedis::SortMethod::ASCENDING_SORT = T.let(T.unsafe(nil), Proc)

# source://mock_redis//lib/mock_redis/sort_method.rb#31
MockRedis::SortMethod::DESCENDING_SORT = T.let(T.unsafe(nil), Proc)

# source://mock_redis//lib/mock_redis/stream/id.rb#2
class MockRedis::Stream
  include ::Enumerable
  extend ::Forwardable

  # @return [Stream] a new instance of Stream
  #
  # source://mock_redis//lib/mock_redis/stream.rb#15
  def initialize; end

  # source://mock_redis//lib/mock_redis/stream.rb#24
  def add(id, values); end

  # source://mock_redis//lib/mock_redis/stream.rb#74
  def each(&block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/stream.rb#20
  def last_id; end

  # Returns the value of attribute members.
  #
  # source://mock_redis//lib/mock_redis/stream.rb#11
  def members; end

  # Sets the attribute members
  #
  # @param value the value to set the attribute members to.
  #
  # source://mock_redis//lib/mock_redis/stream.rb#11
  def members=(_arg0); end

  # source://mock_redis//lib/mock_redis/stream.rb#48
  def range(start, finish, reversed, *opts_in); end

  # source://mock_redis//lib/mock_redis/stream.rb#66
  def read(id, *opts_in); end

  # source://mock_redis//lib/mock_redis/stream.rb#34
  def trim(count); end

  private

  # @raise [Redis::CommandError]
  #
  # source://mock_redis//lib/mock_redis/stream.rb#80
  def options(opts_in, permitted); end
end

# source://mock_redis//lib/mock_redis/stream/id.rb#3
class MockRedis::Stream::Id
  include ::Comparable

  # @return [Id] a new instance of Id
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#8
  def initialize(id, min: T.unsafe(nil), sequence: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream/id.rb#51
  def <=>(other); end

  # Returns the value of attribute exclusive.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def exclusive; end

  # Sets the attribute exclusive
  #
  # @param value the value to set the attribute exclusive to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def exclusive=(_arg0); end

  # Returns the value of attribute sequence.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def sequence; end

  # Sets the attribute sequence
  #
  # @param value the value to set the attribute sequence to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def sequence=(_arg0); end

  # Returns the value of attribute timestamp.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  #
  # source://mock_redis//lib/mock_redis/stream/id.rb#6
  def timestamp=(_arg0); end

  # source://mock_redis//lib/mock_redis/stream/id.rb#47
  def to_s; end
end

# source://mock_redis//lib/mock_redis/stream_methods.rb#28
module MockRedis::StreamMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/stream_methods.rb#32
  def xadd(key, entry, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#49
  def xlen(key); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#55
  def xrange(key, first = T.unsafe(nil), last = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#75
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#65
  def xrevrange(key, last = T.unsafe(nil), first = T.unsafe(nil), count: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#43
  def xtrim(key, count); end

  private

  # source://mock_redis//lib/mock_redis/stream_methods.rb#101
  def assert_streamy(key); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/stream_methods.rb#97
  def streamy?(key); end

  # source://mock_redis//lib/mock_redis/stream_methods.rb#93
  def with_stream_at(key, &blk); end
end

# source://mock_redis//lib/mock_redis/string_methods.rb#4
module MockRedis::StringMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/string_methods.rb#8
  def append(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#318
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#15
  def bitfield(*args); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#81
  def decr(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#85
  def decrby(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#89
  def get(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#95
  def getbit(key, offset); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#112
  def getdel(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#118
  def getrange(key, start, stop); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#123
  def getset(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#129
  def incr(key); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#133
  def incrby(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#147
  def incrbyfloat(key, n); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#172
  def mapped_mget(*keys); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#191
  def mapped_mset(hash); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#206
  def mapped_msetnx(hash); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#160
  def mget(*keys, &blk); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#176
  def mset(*kvpairs); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#195
  def msetnx(*kvpairs); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#355
  def psetex(key, milliseconds, value); end

  # Parameter list required to ensure the ArgumentError is returned correctly
  #
  # source://mock_redis//lib/mock_redis/string_methods.rb#212
  def set(key, value, _hash = T.unsafe(nil), ex: T.unsafe(nil), px: T.unsafe(nil), exat: T.unsafe(nil), pxat: T.unsafe(nil), nx: T.unsafe(nil), xx: T.unsafe(nil), keepttl: T.unsafe(nil), get: T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#271
  def setbit(key, offset, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#345
  def setex(key, seconds, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#365
  def setnx(key, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#374
  def setrange(key, offset, value); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#384
  def strlen(key); end

  private

  # source://mock_redis//lib/mock_redis/string_methods.rb#395
  def assert_stringy(key, message = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#418
  def incr_bitfield(val, incrby, is_signed, type_size, overflow_method); end

  # source://mock_redis//lib/mock_redis/string_methods.rb#405
  def set_bitfield(key, value, is_signed, type_size, offset); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/string_methods.rb#391
  def stringy?(key); end
end

# source://mock_redis//lib/mock_redis/transaction_wrapper.rb#5
class MockRedis::TransactionWrapper
  include ::MockRedis::UndefRedisMethods

  # @return [TransactionWrapper] a new instance of TransactionWrapper
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#12
  def initialize(db); end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#36
  def discard; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#46
  def exec; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#67
  def in_multi?; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#18
  def method_missing(method, *args, **_arg2, &block); end

  # @raise [Redis::BaseError]
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#79
  def multi; end

  # @yield [_self]
  # @yieldparam _self [MockRedis::TransactionWrapper] the object that the method was called on
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#93
  def pipelined; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#75
  def pop_multi; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#71
  def push_multi; end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#8
  def respond_to?(method, include_private = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#97
  def unwatch; end

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#101
  def watch(*_); end

  private

  # source://mock_redis//lib/mock_redis/transaction_wrapper.rb#29
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/undef_redis_methods.rb#2
module MockRedis::UndefRedisMethods
  class << self
    # @private
    #
    # source://mock_redis//lib/mock_redis/undef_redis_methods.rb#3
    def included(klass); end
  end
end

# source://mock_redis//lib/mock_redis/utility_methods.rb#2
module MockRedis::UtilityMethods
  private

  # source://mock_redis//lib/mock_redis/utility_methods.rb#20
  def clean_up_empties_at(key); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#26
  def common_scan(values, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#72
  def left_pad(str, size); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/utility_methods.rb#16
  def primitive?(value); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#61
  def twos_complement_decode(array); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#47
  def twos_complement_encode(n, size); end

  # source://mock_redis//lib/mock_redis/utility_methods.rb#5
  def with_thing_at(key, assertion, empty_thing_generator); end
end

# source://mock_redis//lib/mock_redis/exceptions.rb#2
class MockRedis::WouldBlock < ::StandardError; end

# source://mock_redis//lib/mock_redis/zset.rb#5
class MockRedis::Zset
  include ::Enumerable
  extend ::Forwardable

  # @return [Zset] a new instance of Zset
  #
  # source://mock_redis//lib/mock_redis/zset.rb#13
  def initialize(enum = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset.rb#26
  def add(score, member); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset.rb#32
  def delete?(member); end

  # source://mock_redis//lib/mock_redis/zset.rb#37
  def each; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#41
  def in_range(min, max); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def include?(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#71
  def intersection(other); end

  # Returns the value of attribute members.
  #
  # source://mock_redis//lib/mock_redis/zset.rb#9
  def members; end

  # source://mock_redis//lib/mock_redis/zset.rb#82
  def score(member); end

  # Returns the value of attribute scores.
  #
  # source://mock_redis//lib/mock_redis/zset.rb#9
  def scores; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def size(*args, **_arg1, &block); end

  # source://mock_redis//lib/mock_redis/zset.rb#86
  def sorted; end

  # source://mock_redis//lib/mock_redis/zset.rb#92
  def sorted_members; end

  # source://mock_redis//lib/mock_redis/zset.rb#96
  def union(other); end

  private

  # source://mock_redis//lib/mock_redis/zset.rb#20
  def initialize_copy(source); end
end

# source://mock_redis//lib/mock_redis/zset_methods.rb#6
module MockRedis::ZsetMethods
  include ::MockRedis::Assertions
  include ::MockRedis::UtilityMethods

  # source://mock_redis//lib/mock_redis/zset_methods.rb#10
  def zadd(key, *args); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#93
  def zcard(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#97
  def zcount(key, min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#105
  def zincrby(key, increment, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#116
  def zinterstore(destination, keys, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#240
  def zmscore(key, *members); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#171
  def zpopmax(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#162
  def zpopmin(key, count = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#123
  def zrange(key, start, stop, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#131
  def zrangebyscore(key, min, max, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#140
  def zrank(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#144
  def zrem(key, *args); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#186
  def zremrangebyrank(key, start, stop); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#192
  def zremrangebyscore(key, min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#180
  def zrevrange(key, start, stop, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#200
  def zrevrangebyscore(key, max, min, options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#214
  def zrevrank(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#218
  def zscan(key, cursor, opts = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#223
  def zscan_each(key, opts = T.unsafe(nil), &block); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#233
  def zscore(key, member); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#249
  def zunionstore(destination, keys, options = T.unsafe(nil)); end

  private

  # source://mock_redis//lib/mock_redis/zset_methods.rb#258
  def apply_limit(collection, limit); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#353
  def assert_coercible_zsety(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#374
  def assert_range_args(min, max); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#364
  def assert_scorey(value, message = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#347
  def assert_zsety(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#309
  def coerce_to_zset(set); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#343
  def coercible_zsety?(key); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#281
  def combine_weighted_zsets(keys, options, how); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#359
  def looks_like_float?(x); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#271
  def to_response(score_member_pairs, options); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#317
  def with_zset_at(key, coercible: T.unsafe(nil), &blk); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#327
  def with_zsets_at(*keys, coercible: T.unsafe(nil), &blk); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#62
  def zadd_multiple_members(key, args, zadd_options = T.unsafe(nil)); end

  # source://mock_redis//lib/mock_redis/zset_methods.rb#31
  def zadd_one_member(key, score, member, zadd_options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mock_redis//lib/mock_redis/zset_methods.rb#339
  def zsety?(key); end
end
